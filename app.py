# app.py
import streamlit as st
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend
import io
import zipfile # For creating ZIP archives
import os      # For path joining (though less critical for fixed zip paths)

# --- Core Encryption/Decryption Logic (Unchanged) ---
KEY = b'thermalopenssl.h'
IV = b'thermalopenssl.h'

def decrypt_data(ciphertext: bytes) -> bytes:
    try:
        cipher = Cipher(algorithms.AES(KEY), modes.CBC(IV), backend=default_backend())
        decryptor = cipher.decryptor()
        padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()
        
        unpadder = padding.PKCS7(128).unpadder()
        plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()
        return plaintext
    except ValueError:
        return None

def encrypt_data(plaintext: bytes) -> bytes:
    padder = padding.PKCS7(128).padder()
    padded_data = padder.update(plaintext) + padder.finalize()
    
    cipher = Cipher(algorithms.AES(KEY), modes.CBC(IV), backend=default_backend())
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(padded_data) + encryptor.finalize()
    return ciphertext

# --- Magisk Module Creation Logic ---
def create_magisk_module_zip(encrypted_conf_data: bytes, original_conf_filename: str) -> bytes:
    """
    Creates a basic Magisk module ZIP in memory containing the encrypted .conf file.
    """
    zip_buffer = io.BytesIO()

    # Define Magisk module properties (can be made configurable later)
    module_id = "mithermal-custom-config"
    module_name = "MiThermal Custom Config"
    module_version = "1.0"
    module_version_code = "1"
    module_author = "MiThermal Editor User"
    module_description = f"Custom thermal configuration ({original_conf_filename}) generated by MiThermal Editor."
    
    # Path for the .conf file within the Magisk module's system overlay
    # This assumes the .conf file goes into /system/vendor/etc/
    # Adjust if your target path is different (e.g., /vendor/etc/)
    conf_path_in_zip = f"system/vendor/etc/{original_conf_filename}"

    with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_DEFLATED) as zip_file:
        # 1. Create module.prop
        module_prop_content = (
            f"id={module_id}\n"
            f"name={module_name}\n"
            f"version={module_version}\n"
            f"versionCode={module_version_code}\n"
            f"author={module_author}\n"
            f"description={module_description}\n"
            "minMagisk=1900\n" # Minimum Magisk version (e.g., v19.0)
            # Don't show this module in Magisk Manager (if you want it hidden after install)
            # updateJson=https://raw.githubusercontent.com/you/your-repo/main/update.json # Optional for updates
        ).encode('utf-8')
        zip_file.writestr("module.prop", module_prop_content)

        # 2. Create META-INF structure (dummy/minimal files)
        meta_inf_base = "META-INF/com/google/android/"
        
        # update-binary (must be executable)
        update_binary_content = (
            "#!/sbin/sh\n"
            "# This script is a placeholder.\n"
            "# Magisk's systemless approach will handle placing files from the 'system' directory.\n"
            "ui_print \"***********************************\"\n"
            f"ui_print \"- Installing {module_name} -\"\n"
            f"ui_print \"-      by {module_author}      -\"\n"
            "ui_print \"***********************************\"\n"
            "# No real operations needed by this script if just using system overlay.\n"
            "exit 0\n"
        ).encode('utf-8')
        # Create ZipInfo object to set permissions for update-binary
        update_binary_info = zipfile.ZipInfo(meta_inf_base + "update-binary")
        update_binary_info.external_attr = 0o100755 << 16  # rwxr-xr-x
        update_binary_info.compress_type = zipfile.ZIP_DEFLATED
        zip_file.writestr(update_binary_info, update_binary_content)

        # updater-script (can be minimal)
        updater_script_content = (
            "# This is a placeholder updater-script.\n"
            "# For simple modules that only replace/add files in /system,\n"
            "# Magisk's standard installation process handles it.\n"
        ).encode('utf-8')
        zip_file.writestr(meta_inf_base + "updater-script", updater_script_content)

        # 3. Add the encrypted .conf file to the system overlay path
        # Ensure parent directories for conf_path_in_zip are implicitly created by writestr path
        zip_file.writestr(conf_path_in_zip, encrypted_conf_data)

        # (Optional) Add customize.sh if needed, for this basic case it's not.
        # customize_sh_content = "#!/system/bin/sh\n# Module customization script\n".encode('utf-8')
        # zip_file.writestr("customize.sh", customize_sh_content)

    return zip_buffer.getvalue()

# --- Streamlit Web App Interface ---

st.set_page_config(page_title="MiThermal Editor", layout="centered")

st.title("MiThermal Interactive Editor")
st.markdown("Внимание! Все изменения пар target-trig (частота-температура) вы делаете только на свой риск.")
st.markdown("---")


# Initialize session state
if 'decrypted_text' not in st.session_state:
    st.session_state.decrypted_text = ""
if 'original_filename' not in st.session_state:
    st.session_state.original_filename = "encrypted.conf" # Default if no file uploaded yet

# --- Step 1: File Upload ---
st.subheader("1. Загрузите ваш .conf файл")
uploaded_file = st.file_uploader("Выберите .conf файл для редактирования:", type=['conf'], label_visibility="collapsed")

if uploaded_file is not None:
    st.session_state.original_filename = uploaded_file.name
    
    if st.button("Дешифровать файл", key="decrypt_button"):
        ciphertext = uploaded_file.getvalue()
        plaintext_bytes = decrypt_data(ciphertext)
        
        if plaintext_bytes:
            try:
                # Try decoding with utf-8 first, then latin-1 as a fallback
                st.session_state.decrypted_text = plaintext_bytes.decode('utf-8')
            except UnicodeDecodeError:
                st.session_state.decrypted_text = plaintext_bytes.decode('latin-1') # Fallback
            st.success("Дешифровка успешна. Содержимое доступно в редакторе ниже.")
        else:
            st.error("Ошибка дешифровки! Возможно, файл поврежден, использует другой ключ, или это не зашифрованный .conf файл.")
            st.session_state.decrypted_text = ""

# --- Step 2: Edit Text Area ---
if st.session_state.decrypted_text:
    st.subheader("2. Редактируйте содержимое файла")
    st.caption("Значения таблиц [XXXX-SS-CPU] = target (частота) задаётся в Герцах (2.5ГГц=2500000Гц), значение trig (порог температуры) задаётся в градусах Цельсия, умноженных на 1000 (48000=48С*1000).")
    
    edited_text = st.text_area(
        "Содержимое файла:",
        value=st.session_state.decrypted_text,
        height=400,
        key="editor",
        label_visibility="collapsed"
    )
    
    st.markdown("---")
    st.subheader("3. Сохраните изменения")
    
    # --- Step 3: Encrypt and Download Options ---
    if edited_text: # Only show download if there's text to encrypt
        try:
            # Encode the edited text back to bytes (use the same encoding used for decoding, or a safe one)
            final_plaintext_bytes = edited_text.encode('latin-1') # Using latin-1 for safety with potentially mixed content
        except Exception as e:
            st.error(f"Ошибка кодирования текста перед шифрованием: {e}")
            final_plaintext_bytes = None

        if final_plaintext_bytes:
            final_ciphertext = encrypt_data(final_plaintext_bytes)
            
            col1, col2 = st.columns(2)

            with col1:
                st.download_button(
                    label="📥 Скачать .conf файл",
                    data=final_ciphertext,
                    file_name=f"edited_{st.session_state.original_filename}",
                    mime="application/octet-stream",
                    help="Скачать только зашифрованный .conf файл."
                )
            
            with col2:
                # Create Magisk Module ZIP
                try:
                    magisk_module_zip_data = create_magisk_module_zip(final_ciphertext, st.session_state.original_filename)
                    magisk_zip_filename = f"Magisk_MiThermal_{st.session_state.original_filename.replace('.conf', '')}.zip"
                    
                    st.download_button(
                        label="📦 Скачать Magisk модуль (.zip)",
                        data=magisk_module_zip_data,
                        file_name=magisk_zip_filename,
                        mime="application/zip",
                        help="Скачать файл, упакованный в ZIP-архив Magisk модуля для прошивки."
                    )
                except Exception as e:
                    st.error(f"Ошибка при создании Magisk модуля: {e}")

# --- Footer or additional info ---
st.markdown("---")
st.caption("MiThermal Editor v0.2 | Пользуйтесь с осторожностью.")

# app.py
import streamlit as st
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend
import io
import zipfile # For creating ZIP archives
import os      # For path joining (though less critical for fixed zip paths)

# --- Core Encryption/Decryption Logic (Unchanged) ---
KEY = b'thermalopenssl.h'
IV = b'thermalopenssl.h'

def decrypt_data(ciphertext: bytes) -> bytes:
    try:
        cipher = Cipher(algorithms.AES(KEY), modes.CBC(IV), backend=default_backend())
        decryptor = cipher.decryptor()
        padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()
        
        unpadder = padding.PKCS7(128).unpadder()
        plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()
        return plaintext
    except ValueError:
        return None

def encrypt_data(plaintext: bytes) -> bytes:
    padder = padding.PKCS7(128).padder()
    padded_data = padder.update(plaintext) + padder.finalize()
    
    cipher = Cipher(algorithms.AES(KEY), modes.CBC(IV), backend=default_backend())
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(padded_data) + encryptor.finalize()
    return ciphertext

# --- Magisk Module Creation Logic ---
def create_magisk_module_zip(encrypted_conf_data: bytes, original_conf_filename: str) -> bytes:
    """
    Creates a basic Magisk module ZIP in memory containing the encrypted .conf file.
    """
    zip_buffer = io.BytesIO()

    # Define Magisk module properties (can be made configurable later)
    module_id = "mithermal-custom-config"
    module_name = "MiThermal Custom Config"
    module_version = "1.0"
    module_version_code = "1"
    module_author = "MiThermal Editor User"
    module_description = f"Custom thermal configuration ({original_conf_filename}) generated by MiThermal Editor."
    
    # Path for the .conf file within the Magisk module's system overlay
    # This assumes the .conf file goes into /system/vendor/etc/
    # Adjust if your target path is different (e.g., /vendor/etc/)
    conf_path_in_zip = f"system/vendor/etc/{original_conf_filename}"

    with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_DEFLATED) as zip_file:
        # 1. Create module.prop
        module_prop_content = (
            f"id={module_id}\n"
            f"name={module_name}\n"
            f"version={module_version}\n"
            f"versionCode={module_version_code}\n"
            f"author={module_author}\n"
            f"description={module_description}\n"
            "minMagisk=1900\n" # Minimum Magisk version (e.g., v19.0)
            # Don't show this module in Magisk Manager (if you want it hidden after install)
            # updateJson=https://raw.githubusercontent.com/you/your-repo/main/update.json # Optional for updates
        ).encode('utf-8')
        zip_file.writestr("module.prop", module_prop_content)

        # 2. Create META-INF structure (dummy/minimal files)
        meta_inf_base = "META-INF/com/google/android/"
        
        # update-binary (must be executable)
        update_binary_content = (
            "#!/sbin/sh\n"
            "# This script is a placeholder.\n"
            "# Magisk's systemless approach will handle placing files from the 'system' directory.\n"
            "ui_print \"***********************************\"\n"
            f"ui_print \"- Installing {module_name} -\"\n"
            f"ui_print \"-      by {module_author}      -\"\n"
            "ui_print \"***********************************\"\n"
            "# No real operations needed by this script if just using system overlay.\n"
            "exit 0\n"
        ).encode('utf-8')
        # Create ZipInfo object to set permissions for update-binary
        update_binary_info = zipfile.ZipInfo(meta_inf_base + "update-binary")
        update_binary_info.external_attr = 0o100755 << 16  # rwxr-xr-x
        update_binary_info.compress_type = zipfile.ZIP_DEFLATED
        zip_file.writestr(update_binary_info, update_binary_content)

        # updater-script (can be minimal)
        updater_script_content = (
            "# This is a placeholder updater-script.\n"
            "# For simple modules that only replace/add files in /system,\n"
            "# Magisk's standard installation process handles it.\n"
        ).encode('utf-8')
        zip_file.writestr(meta_inf_base + "updater-script", updater_script_content)

        # 3. Add the encrypted .conf file to the system overlay path
        # Ensure parent directories for conf_path_in_zip are implicitly created by writestr path
        zip_file.writestr(conf_path_in_zip, encrypted_conf_data)

        # (Optional) Add customize.sh if needed, for this basic case it's not.
        # customize_sh_content = "#!/system/bin/sh\n# Module customization script\n".encode('utf-8')
        # zip_file.writestr("customize.sh", customize_sh_content)

    return zip_buffer.getvalue()

# --- Streamlit Web App Interface ---

st.set_page_config(page_title="MiThermal Editor", layout="centered")

st.title("MiThermal Interactive Editor")
st.markdown("Ð’Ð½Ð¸Ð¼Ð°Ð½Ð¸Ðµ! Ð’ÑÐµ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ Ð¿Ð°Ñ€ target-trig (Ñ‡Ð°ÑÑ‚Ð¾Ñ‚Ð°-Ñ‚ÐµÐ¼Ð¿ÐµÑ€Ð°Ñ‚ÑƒÑ€Ð°) Ð²Ñ‹ Ð´ÐµÐ»Ð°ÐµÑ‚Ðµ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð½Ð° ÑÐ²Ð¾Ð¹ Ñ€Ð¸ÑÐº.")
st.markdown("---")


# Initialize session state
if 'decrypted_text' not in st.session_state:
    st.session_state.decrypted_text = ""
if 'original_filename' not in st.session_state:
    st.session_state.original_filename = "encrypted.conf" # Default if no file uploaded yet

# --- Step 1: File Upload ---
st.subheader("1. Ð—Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚Ðµ Ð²Ð°Ñˆ .conf Ñ„Ð°Ð¹Ð»")
uploaded_file = st.file_uploader("Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ .conf Ñ„Ð°Ð¹Ð» Ð´Ð»Ñ Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ:", type=['conf'], label_visibility="collapsed")

if uploaded_file is not None:
    st.session_state.original_filename = uploaded_file.name
    
    if st.button("Ð”ÐµÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ñ„Ð°Ð¹Ð»", key="decrypt_button"):
        ciphertext = uploaded_file.getvalue()
        plaintext_bytes = decrypt_data(ciphertext)
        
        if plaintext_bytes:
            try:
                # Try decoding with utf-8 first, then latin-1 as a fallback
                st.session_state.decrypted_text = plaintext_bytes.decode('utf-8')
            except UnicodeDecodeError:
                st.session_state.decrypted_text = plaintext_bytes.decode('latin-1') # Fallback
            st.success("Ð”ÐµÑˆÐ¸Ñ„Ñ€Ð¾Ð²ÐºÐ° ÑƒÑÐ¿ÐµÑˆÐ½Ð°. Ð¡Ð¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ Ð² Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¾Ñ€Ðµ Ð½Ð¸Ð¶Ðµ.")
        else:
            st.error("ÐžÑˆÐ¸Ð±ÐºÐ° Ð´ÐµÑˆÐ¸Ñ„Ñ€Ð¾Ð²ÐºÐ¸! Ð’Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾, Ñ„Ð°Ð¹Ð» Ð¿Ð¾Ð²Ñ€ÐµÐ¶Ð´ÐµÐ½, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ Ð´Ñ€ÑƒÐ³Ð¾Ð¹ ÐºÐ»ÑŽÑ‡, Ð¸Ð»Ð¸ ÑÑ‚Ð¾ Ð½Ðµ Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ .conf Ñ„Ð°Ð¹Ð».")
            st.session_state.decrypted_text = ""

# --- Step 2: Edit Text Area ---
if st.session_state.decrypted_text:
    st.subheader("2. Ð ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ Ñ„Ð°Ð¹Ð»Ð°")
    st.caption("Ð—Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ Ñ‚Ð°Ð±Ð»Ð¸Ñ† [XXXX-SS-CPU] = target (Ñ‡Ð°ÑÑ‚Ð¾Ñ‚Ð°) Ð·Ð°Ð´Ð°Ñ‘Ñ‚ÑÑ Ð² Ð“ÐµÑ€Ñ†Ð°Ñ… (2.5Ð“Ð“Ñ†=2500000Ð“Ñ†), Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ trig (Ð¿Ð¾Ñ€Ð¾Ð³ Ñ‚ÐµÐ¼Ð¿ÐµÑ€Ð°Ñ‚ÑƒÑ€Ñ‹) Ð·Ð°Ð´Ð°Ñ‘Ñ‚ÑÑ Ð² Ð³Ñ€Ð°Ð´ÑƒÑÐ°Ñ… Ð¦ÐµÐ»ÑŒÑÐ¸Ñ, ÑƒÐ¼Ð½Ð¾Ð¶ÐµÐ½Ð½Ñ‹Ñ… Ð½Ð° 1000 (48000=48Ð¡*1000).")
    
    edited_text = st.text_area(
        "Ð¡Ð¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ Ñ„Ð°Ð¹Ð»Ð°:",
        value=st.session_state.decrypted_text,
        height=400,
        key="editor",
        label_visibility="collapsed"
    )
    
    st.markdown("---")
    st.subheader("3. Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚Ðµ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ")
    
    # --- Step 3: Encrypt and Download Options ---
    if edited_text: # Only show download if there's text to encrypt
        try:
            # Encode the edited text back to bytes (use the same encoding used for decoding, or a safe one)
            final_plaintext_bytes = edited_text.encode('latin-1') # Using latin-1 for safety with potentially mixed content
        except Exception as e:
            st.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° ÐºÐ¾Ð´Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ñ‚ÐµÐºÑÑ‚Ð° Ð¿ÐµÑ€ÐµÐ´ ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼: {e}")
            final_plaintext_bytes = None

        if final_plaintext_bytes:
            final_ciphertext = encrypt_data(final_plaintext_bytes)
            
            col1, col2 = st.columns(2)

            with col1:
                st.download_button(
                    label="ðŸ“¥ Ð¡ÐºÐ°Ñ‡Ð°Ñ‚ÑŒ .conf Ñ„Ð°Ð¹Ð»",
                    data=final_ciphertext,
                    file_name=f"edited_{st.session_state.original_filename}",
                    mime="application/octet-stream",
                    help="Ð¡ÐºÐ°Ñ‡Ð°Ñ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð·Ð°ÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ .conf Ñ„Ð°Ð¹Ð»."
                )
            
            with col2:
                # Create Magisk Module ZIP
                try:
                    magisk_module_zip_data = create_magisk_module_zip(final_ciphertext, st.session_state.original_filename)
                    magisk_zip_filename = f"Magisk_MiThermal_{st.session_state.original_filename.replace('.conf', '')}.zip"
                    
                    st.download_button(
                        label="ðŸ“¦ Ð¡ÐºÐ°Ñ‡Ð°Ñ‚ÑŒ Magisk Ð¼Ð¾Ð´ÑƒÐ»ÑŒ (.zip)",
                        data=magisk_module_zip_data,
                        file_name=magisk_zip_filename,
                        mime="application/zip",
                        help="Ð¡ÐºÐ°Ñ‡Ð°Ñ‚ÑŒ Ñ„Ð°Ð¹Ð», ÑƒÐ¿Ð°ÐºÐ¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð² ZIP-Ð°Ñ€Ñ…Ð¸Ð² Magisk Ð¼Ð¾Ð´ÑƒÐ»Ñ Ð´Ð»Ñ Ð¿Ñ€Ð¾ÑˆÐ¸Ð²ÐºÐ¸."
                    )
                except Exception as e:
                    st.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ð¸ Magisk Ð¼Ð¾Ð´ÑƒÐ»Ñ: {e}")

# --- Footer or additional info ---
st.markdown("---")
st.caption("MiThermal Editor v0.2 | ÐŸÐ¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚ÐµÑÑŒ Ñ Ð¾ÑÑ‚Ð¾Ñ€Ð¾Ð¶Ð½Ð¾ÑÑ‚ÑŒÑŽ.")
